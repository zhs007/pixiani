# 项目概要: PixiJS 动画库

这是一个使用 Pixi.js 和 TypeScript 开发的、面向移动端竖屏的 Web 游戏动画库。

## 重要信息与规则

### 技术栈

- **渲染引擎:** Pixi.js (最新版)
- **渲染模式:** WebGL
- **开发语言:** TypeScript
- **构建工具:** Vite
- **测试框架:** Vitest

### 核心设计原则

1.  **模块化:** 功能被划分到不同的 "package" (目录) 中。`core` 包含核心逻辑, `animations` 包含具体的动画实现。
2.  **类型安全:** 所有模块都必须有完整的 TypeScript 类型定义。核心类型定义在 `src/core/types.ts`。
3.  **高可测试性:** 核心逻辑模块必须有单元测试，目标覆盖率 > 90%。
4.  **详细注释:** 所有公开的类、方法和复杂逻辑都需要有 JSDoc 注释。
5.  **关注相对变换:** 动画应该只修改 Sprite 的相对属性（如相对于其初始状态的缩放、位置偏移），而不是其在世界坐标系中的绝对位置。

### 核心模块

- **`AnimationManager`**: 全局单例，用于注册、创建和管理所有动画实例的生命周期，包括全局暂停、恢复和变速。
- **`BaseObject`**: 一个可以附加动画组件的容器。游戏中的对象可以通过组合 `BaseObject` 来获得动画能力。
- **`BaseAnimate`**: 所有具体动画的基类，定义了动画的基本接口 (`play`, `pause`, `update` 等)。

### Sprite 插槽机制

- 动画不直接创建 `Sprite`，而是通过外部传入一组 `Sprite`（即插槽）来工作。
- 每个动画类必须实现一个方法，用于声明它需要多少个 `Sprite` 插槽。
- 动画逻辑负责决定如何使用这些传入的 `Sprite`。

### 渲染顺序

- 动画库本身不直接修改 `PIXI.Sprite` 的 `zIndex` 或渲染顺序。
- 如果动画需要改变渲染顺序（例如，一个角色转身，需要将后发切换为前发），它会通过一个回调函数通知外部使用者，由外部逻辑来调整 `Sprite` 在 Pixi 容器中的层级。

### 开发流程

1.  **定义类型:** 在 `src/core/types.ts` 中添加新的接口或类型。
2.  **实现核心逻辑:** 在 `src/core` 中实现或修改核心类。
3.  **编写动画:** 在 `src/animations` 目录下创建新的动画文件，继承 `BaseAnimate`。
4.  **编写测试:** 在 `tests` 目录下为新功能编写单元测试。
5.  **演示验证:** 在 `demo` 页面中添加新的测试用例，直观地验证动画效果。
6.  **构建与提交:** 运行 `npm run build` 和 `npm run test`，确保一切正常后提交。

### 命令

- `npm run dev`: 启动开发服务器，访问 `demo/index.html`。
- `npm run build`: 构建生产版本的库。
- `npm run test`: 运行单元测试。

## 开发进度

- [x] **任务 1: 项目初始化与结构搭建** - 完成
- [x] **任务 2: 核心模块设计与实现** - 完成
- [x] **任务 3: 实现第一个动画** - 完成
- [x] **任务 4: 单元测试** - 完成
- [x] **任务 5: 演示页面开发** - 完成
- [x] **任务 6: 构建与整合** - 完成
- [x] **任务 7: 最终审查与提交** - 完成
- [x] **任务 8: Gemini 动画编辑器** - 新增一个基于 Web 的子项目，允许用户通过自然语言描述生成、预览和下载新的动画。
- [x] **任务 9: Gemini TDD 流程** - 为 Gemini Agent 实现一个完整的测试驱动开发（TDD）工作流，使其能够编写代码、编写测试、运行测试并根据结果进行调试。

## Gemini 动画编辑器

### 如何运行

1.  在项目根目录创建一个 `.env` 文件。
2.  在 `.env` 文件中添加您的 Gemini API 密钥: `GEMINI_API_KEY=your_api_key_here`
3.  (可选) 您也可以指定要使用的模型: `GEMINI_MODEL=gemini-1.5-pro` (默认为 `gemini-1.5-flash`)
4.  运行编辑器的开发服务器: `npm run dev:editor`
5.  在浏览器中打开 `http://localhost:3000`。

### TDD 工作流

为了提高 AI 生成代码的质量和可靠性，编辑器后端实现了一个**自主的、自动化的测试驱动开发（TDD）循环**。当用户提交一个动画需求后，Agent 会自动执行完整的工作流，并通过流式响应将进度实时反馈给用户。

#### 用户体验

- **实时反馈**: 用户可以实时看到 Agent 正在执行哪个步骤（例如，“*正在调用工具: create_test_file...*”），而不是面对一个不确定的加载指示器。
- **无缝预览**: Agent 任务成功后，新生成的动画会立即出现在右侧的预览面板中，并被自动选中，用户可以马上播放和测试。
- **自主运行**: 整个工作流是全自动的。用户提交需求后，无需任何进一步干预。

#### 内部工作流程

1.  **启动**: 用户提交需求后，后端启动一个与该会话绑定的 Agent。
2.  **执行循环 (上限10步)**: Agent 进入一个最多10个步骤的执行循环。
    a. **分析与探索**: Agent 调用 `get_allowed_files` 和 `read_file` 工具来学习现有代码。
    b. **编写代码**: Agent 使用 `create_animation_file` 工具生成动画类。
    c. **编写测试**: Agent 使用 `create_test_file` 为新动画编写 Vitest 测试。
    d. **测试与调试**: Agent 调用 `run_tests` 执行测试。该测试运行在一个正确配置的环境中：`vitest`被显式配置为加载项目的路径别名（如`pixi-animation-library`），并被配置为能够发现和执行沙箱 (`.sessions`) 内的测试文件。
    e. **错误处理**: 如果测试因代码错误而失败，Agent 会收到错误报告并尝试修复。如果测试因无法解决的**环境问题**而失败（例如，测试工具本身出现故障），Agent 会识别出这种 `SYSTEM_ERROR`，立即停止工作流程，并向用户报告该环境问题。
3.  **完成**: 一旦测试通过，Agent 会向前端发送最终的成功消息和一个 `workflow_complete` 事件，其中包含新动画的类名。
4.  **沙箱环境**: 所有文件操作和测试都在一个与用户会话绑定的沙箱环境 (`.sessions/<session-id>`) 中进行，以确保项目源代码的安全。
